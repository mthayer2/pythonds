<?xml version="1.0"?>
<section xml:id="algorithm-analysis_what-is-algorithm-analysis">
  <title>What Is Algorithm Analysis?</title>
  <p>It is very common for beginning computer science students to
            compare their programs with one another. You may also have noticed that
            it is common for computer programs to look very similar, especially the
            simple ones. An interesting question often arises. When two programs
            solve the same problem but look different, is one program better than
            the other?</p>
  <p>In order to answer this question, we need to remember that there is an
            important difference between a program and the underlying algorithm that
            the program is representing. As we stated in Chapter 1, an algorithm is
            a generic, step-by-step list of instructions for solving a problem. It
            is a method for solving any instance of the problem so that given a
            particular input, the algorithm produces the desired result. A program,
            on the other hand, is an algorithm that has been encoded into some
            programming language. There may be many programs for the same algorithm,
            depending on the programmer and the programming language being used.</p>
  <p>To explore this difference further, consider the function shown in
            <xref ref="lst-sum1"/>. This function solves a familiar problem, computing the
            sum of the first <em>n</em> integers. The algorithm uses the idea of an
            accumulator variable that is initialized to 0. The solution then
            iterates through the <em>n</em> integers, adding each to the accumulator.</p>
  <listing xml:id="lst-sum1"> <program label="lst-sum1"   interactive="activecode" language="python">
    <input>
def sum_of_n(n):
    the_sum = 0
    for i in range(1, n + 1):
        the_sum = the_sum + i

    return the_sum


print(sum_of_n(10))
        </input>
  </program>
  </listing>
  <p>Now look at the function in <xref ref="lst-sum2"/>. At first glance it may look
            strange, but upon further inspection you can see that this function is
            essentially doing the same thing as the previous one. The reason this is
            not obvious is poor coding. We did not use good identifier names to
            assist with readability, and we used an extra assignment statement
            that was not really necessary during the accumulation step.</p>
  <listing xml:id="lst-sum2"> <program label="lst-sum2"  interactive="activecode" language="python">
    <input>
def foo(tom):
    fred = 0
    for bill in range(1, tom + 1):
        barney = bill
        fred = fred + barney

    return fred


print(foo(10))
        </input>
  </program>
  </listing>
  <p>The question we raised earlier asked whether one function is better than
            another. The answer depends on your criteria. The function <c>sum_of_n</c> is
            certainly better than the function <c>foo</c> if you are concerned with
            readability. In fact, you have probably seen many examples of this in
            your introductory programming course since one of the goals there is to
            help you write programs that are easy to read and easy to understand. In
            this course, however, we are also interested in characterizing the
            algorithm itself. (We certainly hope that you will continue to strive to
            write readable, understandable code.)</p>
  <exercises>
    <title>Self Check</title>
    <exercise label="algo_analysis_sc1">
      <statement>
        <p>Which of the following best describes the relationship between
                    <c>sum_of_n</c> and <c>foo</c>?</p>
      </statement>
      <choices>
        <choice>
          <statement>
            <p><c>foo</c> is more efficient because it uses fewer variables.</p>
          </statement>
          <feedback>
            <p>The extra variable <c>barney</c> does not change the number of
                        fundamental operations the algorithm performs.</p>
          </feedback>
        </choice>
        <choice>
          <statement>
            <p>They use different algorithms to solve the problem.</p>
          </statement>
          <feedback>
            <p>Look more carefully&#x2014;both iterate through the integers and
                        accumulate a sum. The underlying algorithm is the same.</p>
          </feedback>
        </choice>
        <choice correct="yes">
          <statement>
            <p>They use the same algorithm, but <c>sum_of_n</c> is more readable.</p>
          </statement>
          <feedback>
            <p>Correct! Both functions implement the same accumulation algorithm.
                        The only difference is readability&#x2014;good variable names and
                        clean structure make <c>sum_of_n</c> easier to understand.</p>
          </feedback>
        </choice>
        <choice>
          <statement>
            <p><c>sum_of_n</c> is faster because it uses better variable names.</p>
          </statement>
          <feedback>
            <p>Variable names have no effect on execution speed. The computer
                        does not care what you call your variables.</p>
          </feedback>
        </choice>
      </choices>
    </exercise>
  </exercises>
  <p>Algorithm analysis is concerned with comparing algorithms based upon the
            amount of computing resources that each algorithm uses. We want to be
            able to consider two algorithms and say that one is better than the
            other because it is more efficient in its use of those resources or
            perhaps because it simply uses fewer. From this perspective, the two
            functions above seem very similar. They both use essentially the same
            algorithm to solve the summation problem.</p>
  <p>To see what a genuinely different algorithm looks like, consider the
            function in <xref ref="lst-sum-nested"/>. This version uses a nested
            loop to compute the same sum: for each value of <c>i</c>, an inner loop
            adds 1 exactly <c>i</c> times. It produces the correct answer, but
            as we will soon see, the amount of work it performs grows much faster
            as <c>n</c> increases.</p>
  <listing xml:id="lst-sum-nested"> <program label="lst-sum-nested" interactive="activecode" language="python">
    <input>
def sum_of_n_nested(n):
    the_sum = 0
    for i in range(1, n + 1):
        for j in range(i):
            the_sum = the_sum + 1

    return the_sum


print(sum_of_n_nested(10))
        </input>
  </program>
  </listing>
  <p>At this point, it is important to think more about what we really mean
            by computing resources. There are two different ways to look at this.
            One way is to consider the amount of space or memory an algorithm
            requires to solve the problem. The amount of space required by a problem
            solution is typically dictated by the problem instance itself. Every so
            often, however, there are algorithms that have very specific space
            requirements, and in those cases we will be very careful to explain the
            variations.</p>
  <p>As an alternative to space requirements, we can analyze and compare
            algorithms based on the amount of time they require to execute. This
            measure is sometimes referred to as the <em>execution time</em> or <em>running
                time</em> of the algorithm. One way we can measure the execution time for
            the function <c>sum_of_n</c> is to do a <term>benchmark analysis</term>. This means that
            we will track the actual time required for the program to compute its
            result. In Python, we can benchmark a function by noting the starting
            time and ending time within the system we are using. In the
            <c>time</c> module there is a function called <c>time</c> that will return the
            current system clock time in seconds since some arbitrary starting
            point. By calling this function twice, at the beginning and at the end,
            and then computing the difference, we can get an exact number of seconds
            (fractions in most cases) for execution.</p>
  <listing xml:id="algorithm-analysis_lst-sum11"><program label="algorithm-analysis_lst-sum11" interactive="activecode" language="python">
    <input>
# Benchmarking the Iterative Approach
# ------------------------------------
# This function wraps our simple iterative summation with timing code.
# We record the clock before and after the loop, then report the
# difference so we can see how long the computation takes.
# Try to spot the pattern: what happens to the time each time n doubles?

import time


def sum_of_n_2(n):
    start = time.time()

    the_sum = 0
    for i in range(1, n + 1):
        the_sum = the_sum + i

    end = time.time()

    return the_sum, end - start


for n in [100, 200, 400, 800]:
    result, elapsed = sum_of_n_2(n)
    print("n=%4d | Sum=%10d | Time=%10.7f seconds" % (n, result, elapsed))
</input>
  </program></listing>
  <p><xref ref="algorithm-analysis_lst-sum11"/> shows the original <c>sum_of_n</c> function with the timing
            calls embedded before and after the summation. The function returns a
            tuple consisting of the result and the amount of time (in seconds)
            required for the calculation. Run the code above and observe the
            output for each value of <c>n</c>. You should notice that as <c>n</c>
            doubles, the time roughly doubles as well&#x2014;a proportional
            relationship.</p>
  <p>Now let us apply the same benchmarking technique to our nested-loop
            version. Run the code in <xref ref="lst-sum-nested-2"/> and compare
            the results to what you observed above.</p>
  <listing xml:id="lst-sum-nested-2"><program label="lst-sum-nested-2" interactive="activecode" language="python">
    <input>
# Benchmarking the Nested-Loop Approach
# ---------------------------------------
# This function computes the same sum, but uses a nested loop:
# for each value of i, an inner loop adds 1 exactly i times.
# The result is the same, but watch the time column carefully.
# How does the time change each time n doubles?

import time


def sum_of_n_nested_2(n):
    start = time.time()

    the_sum = 0
    for i in range(1, n + 1):
        for j in range(i):
            the_sum = the_sum + 1

    end = time.time()

    return the_sum, end - start


for n in [100, 200, 400, 800]:
    result, elapsed = sum_of_n_nested_2(n)
    print("n=%4d | Sum=%10d | Time=%10.7f seconds" % (n, result, elapsed))
</input>
  </program></listing>
  <p>Notice the dramatic difference. While the iterative version's time
            roughly doubles when <c>n</c> doubles, the nested-loop version's time
            roughly <em>quadruples</em>. This is because the nested loop performs
            approximately <m>\frac{n^2}{2}</m> operations<fn>Where does
            <m>\frac{n^2}{2}</m> come from? The inner loop runs 1 time when
            <c>i=1</c>, then 2 times when <c>i=2</c>, then 3 times when
            <c>i=3</c>, and so on up to <c>n</c> times when <c>i=n</c>. The
            total number of inner-loop executions is therefore
            <m>1 + 2 + 3 + \cdots + n</m>. This is a well-known arithmetic series
            whose sum equals <m>\frac{n(n+1)}{2} = \frac{n^2 + n}{2}</m>. For
            large values of <c>n</c>, the <m>n^2</m> term dominates, so we
            approximate this as <m>\frac{n^2}{2}</m>.</fn>&#x2014;doubling <c>n</c>
            means four times the work. This contrast between doubling and
            quadrupling is the difference between linear and quadratic growth.</p>
  <exercises>
    <title>Self Check</title>
    <exercise label="algo_analysis_sc2">
      <statement>
        <p>The iterative <c>sum_of_n</c> takes approximately 0.0019 seconds
                    for <c>n</c> = 10,000 and about 10 times longer each time we
                    multiply <c>n</c> by 10. Based on this pattern, approximately how
                    long would you expect it to take for <c>n</c> = 10,000,000?</p>
      </statement>
      <choices>
        <choice>
          <statement>
            <p>0.019 seconds</p>
          </statement>
          <feedback>
            <p>That would only be 10 times longer than <c>n</c> = 10,000. But
                        10,000,000 is 1,000 times larger than 10,000.</p>
          </feedback>
        </choice>
        <choice>
          <statement>
            <p>0.19 seconds</p>
          </statement>
          <feedback>
            <p>That would be 100 times longer. We need to go from 10,000 to
                        10,000,000&#x2014;three factors of 10.</p>
          </feedback>
        </choice>
        <choice correct="yes">
          <statement>
            <p>1.9 seconds</p>
          </statement>
          <feedback>
            <p>Correct! Each 10x increase in <c>n</c> causes a 10x increase in
                        time. Going from 10,000 to 10,000,000 is three factors of 10,
                        so the time increases by 10 &#xD7; 10 &#xD7; 10 = 1,000.
                        That gives us 0.0019 &#xD7; 1,000 &#x2248; 1.9 seconds.</p>
          </feedback>
        </choice>
        <choice>
          <statement>
            <p>19 seconds</p>
          </statement>
          <feedback>
            <p>That would be 10,000 times longer, which is one factor of 10
                        too many. Count the steps: 10,000 &#x2192; 100,000 &#x2192;
                        1,000,000 &#x2192; 10,000,000 is only three jumps of 10x.</p>
          </feedback>
        </choice>
      </choices>
    </exercise>
  </exercises>
  <p>Now consider <xref ref="lst-sum3"/>, which shows a very different means of
            solving the summation problem. Instead of using a loop, this function
            takes advantage of a well-known mathematical formula attributed to the
            mathematician Carl Friedrich Gauss. The notation
            <m>\sum_{i=1}^{n} i</m> is called <term>summation notation</term>
            (or sigma notation) and is a compact way of writing
            <q>add up all values of <m>i</m> from 1 to <m>n</m></q>&#x2014;in
            other words, <m>1 + 2 + 3 + \cdots + n</m>. Gauss discovered that
            this sum always equals <m>\frac{n(n+1)}{2}</m>. For example, the sum
            of the first 10 integers is <m>\frac{10 \times 11}{2} = 55</m>.
            This means we can compute the answer with a single arithmetic
            expression&#x2014;no loop required.</p>
<listing xml:id="lst-sum3"> <program label="lst-sum3"   interactive="activecode" language="python">
    <input>
# Benchmarking the Closed-Form (Formula) Approach
# -------------------------------------------------
# This function uses Gauss's formula: n*(n+1)/2
# There is no loop at all -- just one multiplication, one addition,
# and one division. Watch what happens to the time as n grows.

import time


def sum_of_n_3(n):
    start = time.time()
    the_sum = (n * (n + 1)) / 2
    end = time.time()
    return the_sum, end - start


for n in [100, 200, 400, 800]:
    result, elapsed = sum_of_n_3(n)
    print("n=%4d | Sum=%10d | Time=%10.7f seconds" % (n, result, elapsed))
        </input>
  </program>
</listing>
  <p>Run the code above and compare the times to what you saw for the
            iterative and nested-loop versions. There are two important things to
            notice. First, the times are dramatically shorter than any of the
            previous examples. Second, they are essentially the same no matter
            what the value of <c>n</c>. It appears that <c>sum_of_n_3</c> is
            hardly impacted by the number of integers being added&#x2014;this is
            constant-time behavior.</p>
  <p>But what does this benchmark really tell us? Intuitively, we can see
            that the iterative solutions seem to be doing more work since some
            program steps are being repeated. This is likely the reason it is taking
            longer. Also, the time required for the iterative solution seems to
            increase as we increase the value of <c>n</c>. However, if we ran the same
            function on a different computer or used a different
            programming language, we would likely get different results. It could
            take even longer to perform <c>sum_of_n_3</c> if the computer were older.</p>
  <p>What about our nested-loop version, <c>sum_of_n_nested</c>? Try
            running the combined benchmark in <xref ref="lst-benchmark-all"/> to
            compare all three approaches side by side.</p>
  <listing xml:id="lst-benchmark-all"> <program label="lst-benchmark-all" interactive="activecode" language="python">
    <input>
import time

def sum_of_n(n):
    the_sum = 0
    for i in range(1, n + 1):
        the_sum = the_sum + i
    return the_sum

def sum_of_n_nested(n):
    the_sum = 0
    for i in range(1, n + 1):
        for j in range(i):
            the_sum = the_sum + 1
    return the_sum

def sum_of_n_formula(n):
    return (n * (n + 1)) / 2

for size in [100, 200, 400, 800]:
    start = time.time()
    sum_of_n(size)
    iter_time = time.time() - start

    start = time.time()
    sum_of_n_nested(size)
    nested_time = time.time() - start

    start = time.time()
    sum_of_n_formula(size)
    formula_time = time.time() - start

    print("n=%6d: iterative=%10.7fs  nested=%10.7fs  formula=%10.7fs"
          % (size, iter_time, nested_time, formula_time))
        </input>
  </program>
  </listing>
  <p>When you run this benchmark, you will notice three distinct growth
            patterns. The iterative version's time increases proportionally with
            <c>n</c>&#x2014;double <c>n</c>, and the time roughly doubles. We call
            this <term>linear</term> growth. The nested-loop version grows much
            faster: double <c>n</c>, and the time roughly quadruples. This is
            <term>quadratic</term> growth. The formula-based version takes essentially
            the same time regardless of <c>n</c>. This is <term>constant</term> time.</p>
  <exercises>
    <title>Self Check</title>
    <exercise label="algo_analysis_sc3">
      <statement>
        <p>Suppose an algorithm uses a triply-nested loop, where each
                    loop runs <c>n</c> times. If you double the input size <c>n</c>,
                    approximately how much longer will the algorithm take?</p>
      </statement>
      <choices>
        <choice>
          <statement>
            <p>2 times as long</p>
          </statement>
          <feedback>
            <p>That would be linear growth (one loop). Three nested loops
                        means the input size is multiplied together three times.</p>
          </feedback>
        </choice>
        <choice>
          <statement>
            <p>4 times as long</p>
          </statement>
          <feedback>
            <p>That would be quadratic growth (two nested loops). Think about
                        what happens with three.</p>
          </feedback>
        </choice>
        <choice correct="yes">
          <statement>
            <p>8 times as long</p>
          </statement>
          <feedback>
            <p>Correct! With three nested loops, the work is proportional to
                        <m>n^3</m>. Doubling <c>n</c> gives <m>2^3 = 8</m> times the
                        work. This is called <em>cubic</em> growth.</p>
          </feedback>
        </choice>
        <choice>
          <statement>
            <p>6 times as long</p>
          </statement>
          <feedback>
            <p>The growth isn't additive (2+2+2). Each loop multiplies
                        the amount of work: <m>2 \times 2 \times 2 = 8</m>.</p>
          </feedback>
        </choice>
      </choices>
    </exercise>
  </exercises>
  <p>These growth patterns become even clearer if, instead of measuring
            wall-clock time, we simply count the number of operations each
            algorithm performs. Consider the assignment
            <c>the_sum = the_sum + i</c> as the dominant operation in the
            iterative solution. It executes exactly <m>n</m> times. For the
            nested-loop version, the inner assignment
            <c>the_sum = the_sum + 1</c> executes
            <m>1 + 2 + 3 + \cdots + n = \frac{n(n+1)}{2}</m> times. For the
            closed-form solution, there is just one calculation regardless of
            <c>n</c>.</p>
  <table>
    <title>Operation Counts for Three Summation Algorithms</title>
    <tabular halign="center">
      <row header="yes" bottom="medium">
        <cell right="minor"><m>n</m></cell>
        <cell right="minor">Iterative</cell>
        <cell right="minor">Nested Loop</cell>
        <cell>Formula</cell>
      </row>
      <row bottom="minor">
        <cell right="minor">100</cell>
        <cell right="minor">100</cell>
        <cell right="minor">5,050</cell>
        <cell>1</cell>
      </row>
      <row bottom="minor">
        <cell right="minor">1,000</cell>
        <cell right="minor">1,000</cell>
        <cell right="minor">500,500</cell>
        <cell>1</cell>
      </row>
      <row bottom="minor">
        <cell right="minor">10,000</cell>
        <cell right="minor">10,000</cell>
        <cell right="minor">50,005,000</cell>
        <cell>1</cell>
      </row>
      <row>
        <cell right="minor">100,000</cell>
        <cell right="minor">100,000</cell>
        <cell right="minor">5,000,050,000</cell>
        <cell>1</cell>
      </row>
    </tabular>
  </table>
  <exercises>
    <title>Self Check</title>
    <exercise label="algo_analysis_sc4">
      <statement>
        <p>Consider the following function. How many times does the
                    assignment <c>total = total + i * j</c> execute?</p>
        <program language="python">
          <input>
def mystery(n):
    total = 0
    for i in range(n):
        for j in range(n):
            total = total + i * j
    return total
          </input>
        </program>
      </statement>
      <choices>
        <choice>
          <statement>
            <p><m>n</m></p>
          </statement>
          <feedback>
            <p>That would be the case if there were only a single loop.
                        Look carefully&#x2014;there are two nested loops.</p>
          </feedback>
        </choice>
        <choice>
          <statement>
            <p><m>2n</m></p>
          </statement>
          <feedback>
            <p>The two loops do not run one after the other; they are
                        <em>nested</em>. The inner loop runs completely for each
                        iteration of the outer loop.</p>
          </feedback>
        </choice>
        <choice>
          <statement>
            <p><m>\frac{n(n+1)}{2}</m></p>
          </statement>
          <feedback>
            <p>This would be the count if the inner loop ran <c>i</c> times
                        instead of <c>n</c> times (like our <c>sum_of_n_nested</c>
                        example). Here, both loops go up to <c>n</c>.</p>
          </feedback>
        </choice>
        <choice correct="yes">
          <statement>
            <p><m>n^2</m></p>
          </statement>
          <feedback>
            <p>Correct! The outer loop runs <m>n</m> times, and for each
                        iteration the inner loop also runs <m>n</m> times, giving
                        <m>n \times n = n^2</m> total executions.</p>
          </feedback>
        </choice>
      </choices>
    </exercise>
  </exercises>
  <p>Counting operations gives us a <em>machine-independent</em> way to
            evaluate an algorithm's efficiency. No matter what computer or
            programming language we use, the iterative algorithm will always
            perform <m>n</m> additions, the nested-loop version will always perform
            approximately <m>\frac{n^2}{2}</m> additions, and the formula will
            always perform one calculation. This idea&#x2014;characterizing an
            algorithm by counting its dominant operations as a function of the
            input size&#x2014;is the foundation of what we will formalize in the
            next section as <term>Big-O notation</term>.</p>
</section>
